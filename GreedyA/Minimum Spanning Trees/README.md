最小生成树：设G = (V, E)是无向连通带权图，即一个网络。E中每条边(v, w)的权为c[v][w]。如果 G 的子图 G' 是一棵包含 G 的所有顶点的树，则称 G' 为 G 的生成树。生成树上各边权的总和称为该生成树的耗费。在 G 的所有生成树中，耗费最小的生成树称为 G 的最小生成树。（Prim算法和Kruskal算法）

![image](https://user-images.githubusercontent.com/55118194/192791581-ae7f6825-c742-47f7-94b8-68d82543d3f3.png)

V[]={1,2,3,4,5,6}

E[][]={

{0, 0, 0, 0, 0, 0, 0},

{0, 0,10,21, 0, 8, 0},

{0,10, 0,18, 5, 0, 6},

{0,21,18, 0, 0,25,19},

{0, 0, 5, 0, 0, 0, 7},

{0, 8, 0,25, 0, 0,33},

{0, 0, 6,19, 7,33, 0}}

Prim加点法：

　　设一个一维数组S记录最小生成树的点，设一个二维数组T记录最小生成树的边。先随机从V选一点添加到S，S={0，3}。然后在E中找出i∈S，j∈V-S,且权重E[i][j]最小的边(i,j)。最后把j点添加到S，S={0，1,j}，把边的权重记录到T，T[i][j]=E[i][j]，循环执行这个过程直到S=V时结束。此时T中所有的边构成G的最小生成树。

Kruskal加边法：

　　设一个二维数组T记录最小生成树的边。首先把G图的每个点当成一个子树的根节点，设一个一维数组S记录每个点对应的子树编号，S={0，1，2，3，4，5，6，7}。遍历E数组把G图的每条边按权重从小到大排序，设一个二维数组K按顺序记录所有边对应的点和权重，例如最短的边是(1,2),权重是1，记作K[1]={1,2,1}。然后从K[1]开始按权重递增顺序查看每一条边，当查看第i条边时，如果其连接的两个点K[i][0]和K[i][1]不在同一子树：S[K[i][0]]≠S[K[i][1]]，就用这条边连接这两颗子树：遍历S，如果S[i]=S[K[i][0]],则S[i]=S[K[i][1]]。同时确定这条边为最小生成树的一条边：T[K[i][0]] [K[i][1]]=K[i][2]。否则就跳过这条边。循环这个过程直到所有点都在同一子树时结束。此时T中所有的边构成G的最小生成树。
