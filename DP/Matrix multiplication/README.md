完全加括号的矩阵连乘积：给定 k 个矩阵{M1, M2, ..., Mk}，其中 Mi 与 Mi+1 是可乘的，i = 1, 2, …, n - 1。考察这 n 个矩阵的连乘积 M1M2...Mk：
　　矩阵A与矩阵B可乘的条件为矩阵A的列数等于矩阵B的行数，若A是一个p*q的矩阵，B是一个q*r的矩阵，则其乘积C=AB是一个p*r的矩阵。由于矩阵乘法满足结合律，所以计算矩阵的连乘可以有许多不同的计算次序。这种计算次序可以用加括号的方式来确定。
例如：
　　计算三个矩阵连乘{A1，A2，A3}；维数分别为10*100 , 100*5 , 5*50
　　按此顺序计算需要的次数((A1*A2)*A3):10X100X5+10X5X50=7500次
　　按此顺序计算需要的次数(A1*(A2*A3)):100X5X50+10X100X50=75000次
　　如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的计算次数最少？
实例：
![image](https://user-images.githubusercontent.com/55118194/192785411-3356d786-df92-47b5-b55e-8037789d560f.png)
首先按规模从小到大分阶段，最小的阶段是俩个矩阵连乘，最大的是六个矩阵连乘，设一个二维数组存放每个连乘矩阵(阶段)的最小相乘次数(状态)：m[i][j]表示连乘矩阵Mi*Mi+1*Mi+2…Mj-1*Mj的状态。设一个一维数组存放所有矩阵的行数和列数：mrc[n+2]={0,18,35,25,17,10,21,36}。
先对规模小的阶段做决策并记录其状态，再根据规模小的阶段的状态推出规模大的阶段的状态。两个矩阵连乘的状态可以直接算出，三个矩阵连乘的状态就要选一个位置加括号，也就是做决策，做了决策就分成两个前面计算过的部分，可以直接算出。例如m[1][3],设加括号的位置为k，则根据矩阵乘法公式有：m[1][3]= m[1][k]+m[k+1][3]+p[1]*p[k+1]*p[3+1]，遍历k的每个值，就能算出连乘矩阵M1*M2*M3的最小相乘次数。其实这个计算方法对两个矩阵连乘时也适用，所以可以合并。由上述分析推出该问题的状态转移方程：
i=j 时：m[i][j]= 0;　　i<j 时：m[i][j]= min{m[i][k]+m[k+1][j]+p[i]*p[k+1]*p[j+1]}(i<=k<j)；
