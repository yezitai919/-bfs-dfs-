0-1背包问题：给定 n 种物品和一背包。物品 i 的重量是wi，其价值为 vi，背包的容量为 c。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?
实例：n = 5，c = 10，w =（3，1，4，5，3），v =（10，6，3，11，12）
用动态规划的思想把问题分成多个阶段，每个阶段的决策就是一个物品放不放入背包这两个选择，决策造成的状态就是当前背包内物品的价值，当前阶段的决策要依赖上一阶段的状态，除此之外当前物品能不能装入背包还要考虑背包的剩余容量(客观条件)。为了方便后面阶段的决策，在当前阶段要对背包剩余容量的每个情况分别做出决策获得多个状态并存储到数组，下一阶段做决策时可以先把当前的物品装入背包，剩余的容量无论是多少都可以从数组中调用前面阶段的装入情况。
先设两个一维数组存储每个物品的重量和价值：int[] w = {0,3, 1, 4, 5, 3} ; int[] v = {0,10, 6, 3, 11, 12};然后设一个二维数组记录每个阶段的所有状态：int[][] cv = new int[n+1][c+1];如图把二维数组cv以表格形式表示，i和j是数组下标，i表示物品编号，j表示背包剩余容量，一维数组w和v放在左边方便参考对应物品的重量和价值。cv[i][j]表示第i个物品在背包剩余容量为j时做出的决策造成的状态。
![image](https://user-images.githubusercontent.com/55118194/192786689-45c20bb8-6022-4d46-b227-7485bdd6d8fc.png)
cv[2][4]表示背包剩余容量j=4时第2个物品的状态，如果装不下或者选择不装，cv[2][4]等于上一阶段j=4时的状态 cv[2-1][4]，如果选择装下的话留给前面阶段的背包剩余容量为4-w[2]，cv[2][4]等于当前物品的价值v[2]加上前面阶段能装下的物品的价值：cv[2-1][ 4-w[2]] ，由此得出状态转移方程：
w[i]>j时：cv[i][j] = cv[i-1][j];
w[i]<=j时：cv[i][j] max{ cv[i-1][ j], cv[i-1][ j-w[i]] + v[i]};

双重0-1背包问题：给定 n 种物品和一背包。物品 i 的重量是weighti，体积是volumei，其价值为 valuei，背包的容量为 c，容积为v。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?

实例：n = 5，c = 5，v = 5，weight =（3，1，4，5，2），volume =（2，4，1，3，5），value = （10，6，3，11，12）

这题比上面那题多了一个限制条件，每个物品能不能装入背包除了要考虑背包容量还要考虑背包容积，为了方便后面阶段的决策，在当前阶段要对背包剩余容量的每个情况分别做出决策获得多个状态并存储到数组，下一阶段做决策时可以先把当前的物品装入背包，剩余的容量无论是多少都可以从数组中调用前面阶段的装入情况。

先设三个一维数组存储每个物品的重量体积和价值：int[] weight = {0,3, 1, 4, 5, 2}; int[] volume = {0,2, 4, 1, 3, 5}; int[] value = {0,10, 6, 3, 11, 12}; 再设一个三维数组存储每个状态值：int [][][] cv = new int[n+1][c+1][v +1]; 如图分别画出表示每个阶段所有状态的表格cv[i]，第一行是备注当前物品的编号重量体积和价值，j表示当前背包剩余容量，k表示当前背包剩余容积，cv[i][j][k]表示第i件物品在背包剩余容量为j，剩余容积为k时的决策造成的当前背包内物品总价值（状态）。
![image](https://user-images.githubusercontent.com/55118194/192787165-afbb0fc0-564c-4503-a423-90d36bca1417.png)
对于当前阶段的物品如果选择不装，当前状态cv[i][j][k]等于上一阶段同情况下的状态cv[i-1][j][k]，如果选择装入，留给上一阶段的容量为j- weight[i]，容积为k- volume[i]，当前状态cv[i][j][k]等于当前物品价值value[i]加上上一阶段容量为j- weight[i]，容积为k- volume[i]时的状态cv[i - 1][j - weight[i]][k - volume[i]]，哪个状态值大选哪个，由此得出每个阶段的状态转移方程：
当weight[i]>j, volume[i]>k时：cv[i][j][k]= cv[i-1][j][k]，
当weight[i]<=j, volume[i]<=k时：
cv[i][j][k] = max(cv[i - 1][j][k], cv[i - 1][j - weight[i]][k - volume[i]] + value[i])。
